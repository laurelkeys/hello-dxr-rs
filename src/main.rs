//
// References:
// - https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12Raytracing
// - https://learn.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide
// - https://github.com/microsoft/windows-rs/tree/master/crates/samples/windows/direct3d12
// - https://landelare.github.io/2023/02/18/dxr-tutorial.html
//

mod consts;
mod transform;

use consts::NO_AA;

use std::{
    cmp::max,
    num::NonZeroU64,
    ops::DerefMut,
    sync::{Arc, Mutex},
};

use windows::{
    Win32::{
        Foundation::*,
        Graphics::{
            Direct3D::*,
            Direct3D12::*,
            Dxgi::{Common::*, *},
        },
        System::SystemInformation::GetTickCount64,
        UI::{HiDpi::*, WindowsAndMessaging::*},
    },
    core::Interface,
};

/// Generated by `dxc shader.hlsl /T lib_6_3 /Fo shader.o`.
const COMPILED_SHADER: &[u8] = include_bytes!("shader.o");

/// Format to be used by the swap chain and render target.
const COLOR_FORMAT: DXGI_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM;

struct Resources {
    cmd_queue: ID3D12CommandQueue,
    fence: ID3D12Fence,
    fence_value: NonZeroU64,
    swap_chain: IDXGISwapChain3,
    render_target: Option<ID3D12Resource>,
    uav_heap: ID3D12DescriptorHeap,

    cmd_allocator: ID3D12CommandAllocator,
    cmd_list: ID3D12GraphicsCommandList4,
}

struct Context {
    // factory: IDXGIFactory4,
    device: ID3D12Device5,
    resources: Resources,
}

impl Context {
    fn new(hwnd: HWND) -> windows::core::Result<Self> {
        let mut factory_flags = DXGI_CREATE_FACTORY_FLAGS::default();

        if cfg!(debug_assertions) {
            unsafe {
                let mut debug: Option<ID3D12Debug> = None;
                if let Some(debug) = D3D12GetDebugInterface(&mut debug).ok().and(debug) {
                    factory_flags |= DXGI_CREATE_FACTORY_DEBUG;
                    debug.EnableDebugLayer();
                }
            }
        }

        let factory: IDXGIFactory4 = unsafe { CreateDXGIFactory2(factory_flags) }?;

        let device = {
            let mut device: Option<ID3D12Device5> = None;
            unsafe { D3D12CreateDevice(None, D3D_FEATURE_LEVEL_12_2, &mut device) }?;
            device.expect("should not be null after D3D12CreateDevice is ok")
        };

        let cmd_queue: ID3D12CommandQueue = unsafe {
            device.CreateCommandQueue(&D3D12_COMMAND_QUEUE_DESC {
                Type: D3D12_COMMAND_LIST_TYPE_DIRECT,
                ..Default::default()
            })
        }?;

        let swap_chain: IDXGISwapChain3 = {
            let swap_chain1: IDXGISwapChain1 = unsafe {
                factory.CreateSwapChainForHwnd(
                    &cmd_queue,
                    hwnd,
                    &DXGI_SWAP_CHAIN_DESC1 {
                        BufferCount: 2,
                        Format: COLOR_FORMAT,
                        BufferUsage: DXGI_USAGE_RENDER_TARGET_OUTPUT,
                        SampleDesc: NO_AA,
                        SwapEffect: DXGI_SWAP_EFFECT_FLIP_DISCARD,
                        ..Default::default()
                    },
                    None,
                    None,
                )
            }?;
            swap_chain1.cast()?
        };

        // drop(factory); // @Test: the factory is no longer needed, so we may as well drop it

        // resize

        let cmd_allocator =
            unsafe { device.CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT) }?;

        let cmd_list = unsafe {
            device.CreateCommandList1(
                0,
                D3D12_COMMAND_LIST_TYPE_DIRECT,
                D3D12_COMMAND_LIST_FLAG_NONE,
            )
        }?;

        let resources = Resources {
            cmd_queue,
            fence: unsafe { device.CreateFence(0, D3D12_FENCE_FLAG_NONE) }?,
            fence_value: NonZeroU64::new(1).unwrap(),
            swap_chain,
            render_target: None, // initialized on `resize`
            uav_heap: unsafe {
                device.CreateDescriptorHeap(&D3D12_DESCRIPTOR_HEAP_DESC {
                    Type: D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
                    NumDescriptors: 1,
                    Flags: D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE,
                    ..Default::default()
                })
            }?,
            cmd_allocator,
            cmd_list,
        };

        Ok(Context { device, resources })
    }
}

fn main() -> windows::core::Result<()> {
    println!("Hello, DXR!");

    println!("Shader byte count: {}", COMPILED_SHADER.len());

    // @Todo: add a CLI option to DPI_AWARENESS_CONTEXT_UNAWARE (e.g. --dpi-unaware).
    unsafe { SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) }?;

    let class_name = windows::core::w!("HelloDxrClass");

    let wcw = WNDCLASSW {
        lpfnWndProc: Some(wnd_proc),
        hCursor: unsafe { LoadCursorW(None, IDC_ARROW) }?,
        lpszClassName: class_name,
        ..Default::default()
    };
    let atom = unsafe { RegisterClassW(&wcw) };
    assert_ne!(atom, 0, "RegisterClassW: {:?}", unsafe { GetLastError() });

    let hwnd = unsafe {
        CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            class_name,
            windows::core::w!("Hello DXR"),
            WS_VISIBLE | WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            None,
            None,
            None,
            None,
        )
    }?;

    let context = Arc::new(Mutex::new(Context::new(hwnd)?));

    // @Test: instead of moving the cloned value with Arc::into_raw, just cast the context to
    // a `*mut Mutex<Context>` and avoid `drop(unsafe { Arc::from_raw(context_ptr) })` in `wnd_proc`.
    let context_for_window = Arc::clone(&context);
    unsafe { SetWindowLongPtrW(hwnd, GWLP_USERDATA, Arc::into_raw(context_for_window) as isize) };

    resize(hwnd, std::ptr::NonNull::new(context.as_ref() as *const _ as *mut _).unwrap());

    // Init Meshes.
    let quad_vertex_buffer =
        make_upload_buffer(&context.lock().unwrap().device, &consts::QUAD_VERTICES)?;
    let cube_vertex_buffer =
        make_upload_buffer(&context.lock().unwrap().device, &consts::CUBE_VERTICES)?;
    let cube_index_buffer =
        make_upload_buffer(&context.lock().unwrap().device, &consts::CUBE_INDICES)?;

    // Init BottomLevel.
    let quad_blas = make_blas(
        context.lock().unwrap().deref_mut(),
        &quad_vertex_buffer,
        (consts::QUAD_VERTICES.len() / 3) as u32,
        None,
    )?;
    let cube_blas = make_blas(
        context.lock().unwrap().deref_mut(),
        &cube_vertex_buffer,
        (consts::CUBE_VERTICES.len() / 3) as u32,
        Some((&cube_index_buffer, consts::CUBE_INDICES.len() as u32)),
    )?;

    // Init Scene.
    let instances_buffer = {
        let mut desc = consts::BASIC_BUFFER_DESC;
        desc.Width =
            (std::mem::size_of::<D3D12_RAYTRACING_INSTANCE_DESC>() * consts::INSTANCE_COUNT) as u64;

        let mut instances_buffer: Option<ID3D12Resource> = None;
        unsafe {
            context.lock().unwrap().device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_UPLOAD, ..Default::default() },
                D3D12_HEAP_FLAG_NONE,
                &desc,
                D3D12_RESOURCE_STATE_COMMON,
                None,
                &mut instances_buffer,
            )
        }?;

        instances_buffer.expect("should not be null after CreateCommittedResource is ok")
    };

    {
        let mut mapped_data = std::ptr::null_mut();

        unsafe { instances_buffer.Map(0, None, Some(&mut mapped_data)) }?;

        let instances_data = mapped_data as *mut D3D12_RAYTRACING_INSTANCE_DESC;
        let instance_descs =
            unsafe { std::slice::from_raw_parts_mut(instances_data, consts::INSTANCE_COUNT) };

        // https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_raytracing_instance_desc
        //
        // typedef struct D3D12_RAYTRACING_INSTANCE_DESC {
        //     FLOAT                     Transform[3][4];
        //     UINT                      InstanceID : 24;
        //     UINT                      InstanceMask : 8;
        //     UINT                      InstanceContributionToHitGroupIndex : 24;
        //     UINT                      Flags : 8;
        //     D3D12_GPU_VIRTUAL_ADDRESS AccelerationStructure;
        // } D3D12_RAYTRACING_INSTANCE_DESC;
        //
        // `Transform` is a 3x4 transform matrix in row-major layout representing the instance-to-world transformation.
        //
        // Note: The layout of `Transform` is a transpose of how affine matrices are typically stored in memory.
        // Instead of four 3-vectors, `Transform` is laid out as three 4-vectors.

        let make_bitfield1 = |instance_id, instance_mask| {
            const MAX_U24: u32 = (1 << 24) - 1;
            const LOW_U8_MASK: u32 = 0xFF; // = (1 << 8) - 1

            (instance_id & MAX_U24) | ((instance_mask & LOW_U8_MASK) << 24)
        };

        for (i, desc) in instance_descs.iter_mut().enumerate() {
            *desc = D3D12_RAYTRACING_INSTANCE_DESC {
                _bitfield1: make_bitfield1(i as u32, 1),
                AccelerationStructure: unsafe {
                    if i == 0 {
                        cube_blas.GetGPUVirtualAddress()
                    } else {
                        quad_blas.GetGPUVirtualAddress() // floor, mirror
                    }
                },
                ..Default::default()
            };
        }

        // Update transforms.
        let [cube_to_world, floor_to_world, mirror_to_world] =
            transform::compute_instance_to_world_transforms(
                unsafe { GetTickCount64() } as f32 / 1000.0,
            );

        instance_descs[0].Transform.copy_from_slice(&cube_to_world);
        instance_descs[1].Transform.copy_from_slice(&floor_to_world);
        instance_descs[2].Transform.copy_from_slice(&mirror_to_world);

        // Do not Unmap.
    }

    // Init TopLevel.
    let (tlas, prebuild_info) = make_tlas(context.lock().unwrap().deref_mut(), &instances_buffer)?;

    let tlas_update_scratch_buffer = make_unordered_access_default_buffer(
        &context.lock().unwrap().device,
        max(prebuild_info.UpdateScratchDataSizeInBytes, 8),
        D3D12_RESOURCE_STATE_COMMON, // UNORDERED_ACCESS,
    )?;

    // @Continue: https://landelare.github.io/2023/02/18/dxr-tutorial.html#root-signature
    // Init RootSignature.
    // Init Pipeline.

    let mut msg = MSG::default();
    loop {
        while unsafe { PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() } {
            if msg.message == WM_QUIT {
                return Ok(());
            }

            unsafe {
                let _translated = TranslateMessage(&msg).as_bool();
                // @Fixme: assert!(translated, "TranslateMessage: {:?}", GetLastError());
                DispatchMessageW(&msg);
            }
        }

        render_frame();
    }
}

fn render_frame() {
    todo!()
}

fn signal_and_wait(
    fence_value: NonZeroU64,
    cmd_queue: &ID3D12CommandQueue,
    fence: &ID3D12Fence,
) -> windows::core::Result<NonZeroU64> {
    unsafe {
        cmd_queue.Signal(fence, fence_value.get())?;
        // Pass HANDLE::default() to lead to a blocking wait.
        fence.SetEventOnCompletion(fence_value.get(), HANDLE::default())?;
    }

    Ok(fence_value.saturating_add(1))
}

fn make_upload_buffer<T: Copy>(
    device: &ID3D12Device5,
    data: &[T],
) -> windows::core::Result<ID3D12Resource> {
    let buffer = {
        let mut desc = consts::BASIC_BUFFER_DESC;
        desc.Width = std::mem::size_of_val(data) as u64;

        let mut buffer: Option<ID3D12Resource> = None;
        unsafe {
            device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_UPLOAD, ..Default::default() },
                D3D12_HEAP_FLAG_NONE,
                &desc,
                D3D12_RESOURCE_STATE_COMMON,
                None,
                &mut buffer,
            )
        }?;

        buffer.expect("should not be null after CreateCommittedResource is ok")
    };

    let mut mapped_data = std::ptr::null_mut();
    unsafe {
        buffer.Map(0, None, Some(&mut mapped_data))?;
        std::ptr::copy_nonoverlapping(data.as_ptr(), mapped_data as *mut T, data.len());
        buffer.Unmap(0, None);
    }

    Ok(buffer)
}

fn make_unordered_access_default_buffer(
    device: &ID3D12Device5,
    size: u64,
    initial_state: D3D12_RESOURCE_STATES,
) -> windows::core::Result<ID3D12Resource> {
    let buffer = {
        let mut desc = consts::BASIC_BUFFER_DESC;
        desc.Width = size;
        desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

        let mut buffer: Option<ID3D12Resource> = None;
        unsafe {
            device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_DEFAULT, ..Default::default() },
                D3D12_HEAP_FLAG_NONE,
                &desc,
                initial_state,
                None,
                &mut buffer,
            )
        }?;

        buffer.expect("should not be null after CreateCommittedResource is ok")
    };

    Ok(buffer)
}

fn make_acceleration_structure(
    context: &mut Context,
    inputs: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
) -> windows::core::Result<(ID3D12Resource, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO)>
{
    let Context { device, resources } = context;

    let mut prebuild_info = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO::default();
    unsafe { device.GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &mut prebuild_info) };

    let scratch_buffer = make_unordered_access_default_buffer(
        device,
        prebuild_info.ScratchDataSizeInBytes,
        D3D12_RESOURCE_STATE_COMMON, // UNORDERED_ACCESS,
    )?;
    let result_buffer = make_unordered_access_default_buffer(
        device,
        prebuild_info.ResultDataMaxSizeInBytes,
        D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE,
    )?;

    let build_desc = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
        DestAccelerationStructureData: unsafe { result_buffer.GetGPUVirtualAddress() },
        Inputs: inputs,
        SourceAccelerationStructureData: 0,
        ScratchAccelerationStructureData: unsafe { scratch_buffer.GetGPUVirtualAddress() },
    };

    unsafe {
        resources.cmd_allocator.Reset()?;
        resources.cmd_list.Reset(&resources.cmd_allocator, None)?;
        resources.cmd_list.BuildRaytracingAccelerationStructure(&build_desc, None);
        resources.cmd_list.Close()?;
        resources.cmd_queue.ExecuteCommandLists(&[Some(resources.cmd_list.cast()?)]); // @Test: double-check .cast()
    };

    resources.fence_value =
        signal_and_wait(resources.fence_value, &resources.cmd_queue, &resources.fence)?;

    Ok((result_buffer, prebuild_info))
}

fn make_blas(
    context: &mut Context,
    vertex_buffer: &ID3D12Resource,
    vertex_count: u32,
    index_buffer_and_count: Option<(&ID3D12Resource, u32)>,
) -> windows::core::Result<ID3D12Resource> {
    let (index_format, index_count, index_buffer) = match index_buffer_and_count {
        // @Hardcode: DXGI_FORMAT_R16_UINT matches the u16 used for CUBE_INDICES.
        Some((index_buffer, count)) => {
            (DXGI_FORMAT_R16_UINT, count, unsafe { index_buffer.GetGPUVirtualAddress() })
        }
        None => (DXGI_FORMAT_UNKNOWN, 0, 0),
    };

    let geometry_desc = D3D12_RAYTRACING_GEOMETRY_DESC {
        Type: D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES,
        Flags: D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE,
        Anonymous: D3D12_RAYTRACING_GEOMETRY_DESC_0 {
            Triangles: D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
                Transform3x4: 0,
                IndexFormat: index_format,
                VertexFormat: DXGI_FORMAT_R32G32B32_FLOAT,
                IndexCount: index_count,
                VertexCount: vertex_count,
                IndexBuffer: index_buffer,
                VertexBuffer: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
                    StartAddress: unsafe { vertex_buffer.GetGPUVirtualAddress() },
                    StrideInBytes: (std::mem::size_of::<f32>() * 3) as u64, // @Hardcode
                },
            },
        },
    };

    // See https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#choosing-acceleration-structure-build-flags
    let inputs = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
        Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL,
        Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE,
        NumDescs: 1,
        DescsLayout: D3D12_ELEMENTS_LAYOUT_ARRAY,
        Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
            pGeometryDescs: &geometry_desc,
        },
    };

    make_acceleration_structure(context, inputs).map(|(result_buffer, _)| result_buffer)
}

fn make_tlas(
    context: &mut Context,
    instances_buffer: &ID3D12Resource,
) -> windows::core::Result<(ID3D12Resource, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO)>
{
    let inputs = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
        Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL,
        Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE,
        NumDescs: consts::INSTANCE_COUNT as u32,
        DescsLayout: D3D12_ELEMENTS_LAYOUT_ARRAY,
        Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
            InstanceDescs: unsafe { instances_buffer.GetGPUVirtualAddress() },
        },
    };

    make_acceleration_structure(context, inputs)
}

extern "system" fn resize(hwnd: HWND, mut context: std::ptr::NonNull<Mutex<Context>>) {
    let mut context = unsafe { context.as_mut() }.lock().unwrap();
    let Context { device, resources } = &mut *context;

    let mut rect = RECT::default();
    unsafe { GetClientRect(hwnd, &mut rect) }.unwrap();
    let width = max(1, rect.right - rect.left);
    let height = max(1, rect.bottom - rect.top);

    resources.fence_value =
        signal_and_wait(resources.fence_value, &resources.cmd_queue, &resources.fence).unwrap();

    unsafe {
        resources.swap_chain.ResizeBuffers(
            0u32, // preserve buffer count
            width as u32,
            height as u32,
            DXGI_FORMAT_UNKNOWN, // preserve existing format
            DXGI_SWAP_CHAIN_FLAG(0),
        )
    }
    .unwrap();

    unsafe {
        device.CreateCommittedResource(
            &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_DEFAULT, ..Default::default() },
            D3D12_HEAP_FLAG_NONE,
            &D3D12_RESOURCE_DESC {
                Dimension: D3D12_RESOURCE_DIMENSION_TEXTURE2D,
                Width: width as u64,
                Height: height as u32,
                DepthOrArraySize: 1,
                MipLevels: 1,
                Format: COLOR_FORMAT,
                SampleDesc: NO_AA,
                Flags: D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
                ..Default::default()
            },
            D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
            None,
            &mut resources.render_target,
        )
    }
    .unwrap();

    let render_target = resources
        .render_target
        .as_ref()
        .expect("should not be null after CreateCommittedResource is ok");

    unsafe {
        device.CreateUnorderedAccessView(
            render_target,
            None,
            Some(&D3D12_UNORDERED_ACCESS_VIEW_DESC {
                Format: COLOR_FORMAT,
                ViewDimension: D3D12_UAV_DIMENSION_TEXTURE2D,
                ..Default::default()
            }),
            resources.uav_heap.GetCPUDescriptorHandleForHeapStart(),
        )
    };
}

extern "system" fn wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    let context_ptr = unsafe { GetWindowLongPtrW(hwnd, GWLP_USERDATA) } as *const Mutex<Context>
        as *mut Mutex<Context>;

    match msg {
        WM_SIZING | WM_SIZE => {
            if let Some(context) = std::ptr::NonNull::new(context_ptr) {
                resize(hwnd, context);
            }
        }
        WM_CLOSE | WM_DESTROY => {
            if !context_ptr.is_null() {
                // Decrease the refcount as we close the window.
                drop(unsafe { Arc::from_raw(context_ptr) });
            }
            unsafe { PostQuitMessage(0) };
        }
        _ => {}
    }

    unsafe { DefWindowProcW(hwnd, msg, wparam, lparam) }
}
