//
// References:
// - https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12Raytracing
// - https://learn.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide
// - https://github.com/microsoft/windows-rs/tree/master/crates/samples/windows/direct3d12
// - https://landelare.github.io/2023/02/18/dxr-tutorial.html
//

mod consts;

use consts::NO_AA;

use std::{
    cmp::max,
    num::NonZeroU64,
    ops::DerefMut,
    sync::{Arc, Mutex},
};

use windows::{
    Win32::{
        Foundation::*,
        Graphics::{
            Direct3D::*,
            Direct3D12::*,
            Dxgi::{Common::*, *},
        },
        UI::{HiDpi::*, WindowsAndMessaging::*},
    },
    core::Interface,
};

/// Generated by `dxc shader.hlsl /T lib_6_3 /Fo shader.o`.
const COMPILED_SHADER: &[u8] = include_bytes!("shader.o");

struct Resources {
    cmd_queue: ID3D12CommandQueue,
    fence: ID3D12Fence,
    fence_value: NonZeroU64,
    swap_chain: IDXGISwapChain3,
    render_target: Option<ID3D12Resource>,
    uav_heap: ID3D12DescriptorHeap,
}

struct Context {
    factory: IDXGIFactory4,
    device: ID3D12Device5,
    resources: Option<Resources>,
}

impl Context {
    fn new() -> windows::core::Result<Self> {
        let mut factory_flags = DXGI_CREATE_FACTORY_FLAGS::default();

        if cfg!(debug_assertions) {
            unsafe {
                let mut debug: Option<ID3D12Debug> = None;
                if let Some(debug) = D3D12GetDebugInterface(&mut debug).ok().and(debug) {
                    factory_flags |= DXGI_CREATE_FACTORY_DEBUG;
                    debug.EnableDebugLayer();
                }
            }
        }

        let factory: IDXGIFactory4 = unsafe { CreateDXGIFactory2(factory_flags) }?;

        let device = {
            let mut device: Option<ID3D12Device5> = None;
            unsafe { D3D12CreateDevice(None, D3D_FEATURE_LEVEL_12_2, &mut device) }?;
            device.expect("device should not be null after D3D12CreateDevice is ok")
        };

        Ok(Self {
            factory,
            device,
            resources: None,
        })
    }
}

fn main() -> windows::core::Result<()> {
    println!("Hello, DXR!");

    println!("Shader byte count: {}", COMPILED_SHADER.len());

    let context = Arc::new(Mutex::new(Context::new()?));

    // @Todo: add a CLI option to DPI_AWARENESS_CONTEXT_UNAWARE (e.g. --dpi-unaware).
    unsafe { SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) }?;

    let class_name = windows::core::w!("HelloDxrClass");

    let wcw = WNDCLASSW {
        lpfnWndProc: Some(wnd_proc),
        hCursor: unsafe { LoadCursorW(None, IDC_ARROW) }?,
        lpszClassName: class_name,
        ..Default::default()
    };
    let atom = unsafe { RegisterClassW(&wcw) };
    assert_ne!(atom, 0, "RegisterClassW: {:?}", unsafe { GetLastError() });

    let hwnd = unsafe {
        CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            class_name,
            windows::core::w!("Hello DXR"),
            WS_VISIBLE | WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            None,
            None,
            None,
            None,
        )
    }?;

    // @Test: instead of moving the cloned value with Arc::into_raw, just cast the context to
    // a `*mut Mutex<Context>` and avoid `drop(unsafe { Arc::from_raw(context_ptr) })` in `wnd_proc`.
    let context_for_window = Arc::clone(&context);
    unsafe {
        SetWindowLongPtrW(
            hwnd,
            GWLP_USERDATA,
            Arc::into_raw(context_for_window) as isize,
        )
    };

    init_resources(hwnd, context)?;

    let mut msg = MSG::default();
    loop {
        while unsafe { PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() } {
            if msg.message == WM_QUIT {
                return Ok(());
            }

            unsafe {
                let _translated = TranslateMessage(&msg).as_bool();
                // @Fixme: assert!(translated, "TranslateMessage: {:?}", GetLastError());
                DispatchMessageW(&msg);
            }
        }

        render_frame();
    }
}

fn render_frame() {
    todo!()
}

fn init_resources(hwnd: HWND, context: Arc<Mutex<Context>>) -> windows::core::Result<()> {
    {
        let mut context = context.lock().unwrap();

        let cmd_queue: ID3D12CommandQueue = unsafe {
            context
                .device
                .CreateCommandQueue(&D3D12_COMMAND_QUEUE_DESC {
                    Type: D3D12_COMMAND_LIST_TYPE_DIRECT,
                    ..Default::default()
                })
        }?;

        let swap_chain: IDXGISwapChain3 = {
            let swap_chain1: IDXGISwapChain1 = unsafe {
                context.factory.CreateSwapChainForHwnd(
                    &cmd_queue,
                    hwnd,
                    &DXGI_SWAP_CHAIN_DESC1 {
                        BufferCount: 2,
                        Format: DXGI_FORMAT_R8G8B8A8_UNORM,
                        BufferUsage: DXGI_USAGE_RENDER_TARGET_OUTPUT,
                        SampleDesc: NO_AA,
                        SwapEffect: DXGI_SWAP_EFFECT_FLIP_DISCARD,
                        ..Default::default()
                    },
                    None,
                    None,
                )
            }?;
            swap_chain1.cast()?
        };

        // drop(context.factory); // @Test: the factory is no longer needed, so we may as well drop it

        context.resources = Some(Resources {
            cmd_queue,
            fence: unsafe { context.device.CreateFence(0, D3D12_FENCE_FLAG_NONE) }?,
            fence_value: NonZeroU64::new(1).unwrap(),
            swap_chain,
            render_target: None, // initialized on `resize`
            uav_heap: unsafe {
                context
                    .device
                    .CreateDescriptorHeap(&D3D12_DESCRIPTOR_HEAP_DESC {
                        Type: D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
                        NumDescriptors: 1,
                        Flags: D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE,
                        ..Default::default()
                    })
            }?,
        });
    }

    resize(hwnd, unsafe {
        std::ptr::NonNull::new_unchecked(context.as_ref() as *const _ as *mut _)
    });

    // @Continue: https://landelare.github.io/2023/02/18/dxr-tutorial.html#command-list-and-allocator
    // Init Command.
    // Init Meshes.
    // Init BottomLevel.
    // Init Scene.
    // Init TopLevel.
    // Init RootSignature.
    // Init Pipeline.

    Ok(())
}

// @Continue: https://landelare.github.io/2023/02/18/dxr-tutorial.html#swap-chain-uav

fn signal_and_wait(
    fence_value: NonZeroU64,
    cmd_queue: &ID3D12CommandQueue,
    fence: &ID3D12Fence,
) -> windows::core::Result<NonZeroU64> {
    unsafe {
        cmd_queue.Signal(fence, fence_value.get())?;
        // Pass HANDLE::default() to lead to a blocking wait.
        fence.SetEventOnCompletion(fence_value.get(), HANDLE::default())?;
    }

    Ok(fence_value.saturating_add(1))
}

extern "system" fn resize(hwnd: HWND, mut context: std::ptr::NonNull<Mutex<Context>>) {
    let mut context = unsafe { context.as_mut() }.lock().unwrap();

    let mut rect = RECT::default();
    unsafe { GetClientRect(hwnd, &mut rect) }.unwrap();
    let width = max(1, rect.right - rect.left);
    let height = max(1, rect.bottom - rect.top);

    if let Context {
        device,
        resources: Some(resources),
        ..
    } = &mut *context
    {
        resources.fence_value = signal_and_wait(
            resources.fence_value,
            &resources.cmd_queue,
            &resources.fence,
        )
        .unwrap();

        unsafe {
            resources.swap_chain.ResizeBuffers(
                0u32, // preserve buffer count
                width as u32,
                height as u32,
                DXGI_FORMAT_UNKNOWN, // preserve existing format
                DXGI_SWAP_CHAIN_FLAG(0),
            )
        }
        .unwrap();

        unsafe {
            device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES {
                    Type: D3D12_HEAP_TYPE_DEFAULT,
                    ..Default::default()
                },
                D3D12_HEAP_FLAG_NONE,
                &D3D12_RESOURCE_DESC {
                    Dimension: D3D12_RESOURCE_DIMENSION_TEXTURE2D,
                    Width: width as u64,
                    Height: height as u32,
                    DepthOrArraySize: 1,
                    MipLevels: 1,
                    Format: DXGI_FORMAT_R8G8B8A8_UNORM,
                    SampleDesc: NO_AA,
                    Flags: D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
                    ..Default::default()
                },
                D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                None,
                &mut resources.render_target,
            )
        }
        .unwrap();

        unsafe {
            device.CreateUnorderedAccessView(
                resources
                    .render_target
                    .as_ref()
                    .expect("render_target should not be null after CreateCommittedResource is ok"),
                None,
                Some(&D3D12_UNORDERED_ACCESS_VIEW_DESC {
                    Format: DXGI_FORMAT_R8G8B8A8_UNORM,
                    ViewDimension: D3D12_UAV_DIMENSION_TEXTURE2D,
                    ..Default::default()
                }),
                resources.uav_heap.GetCPUDescriptorHandleForHeapStart(),
            )
        };
    }
}

extern "system" fn wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    let context_ptr = unsafe { GetWindowLongPtrW(hwnd, GWLP_USERDATA) } as *const Mutex<Context>
        as *mut Mutex<Context>;

    match msg {
        WM_SIZING | WM_SIZE => {
            if let Some(context) = std::ptr::NonNull::new(context_ptr) {
                resize(hwnd, context);
            }
        }
        WM_CLOSE | WM_DESTROY => {
            if !context_ptr.is_null() {
                // Decrease the refcount as we close the window.
                drop(unsafe { Arc::from_raw(context_ptr) });
            }
            unsafe { PostQuitMessage(0) };
        }
        _ => {}
    }

    unsafe { DefWindowProcW(hwnd, msg, wparam, lparam) }
}
