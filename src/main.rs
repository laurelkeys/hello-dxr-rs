//
// References:
// - https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12Raytracing
// - https://learn.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide
// - https://github.com/microsoft/windows-rs/tree/master/crates/samples/windows/direct3d12
// - https://landelare.github.io/2023/02/18/dxr-tutorial.html
//

mod consts;
mod transform;

use consts::NO_AA;

use std::{
    cmp::max,
    num::NonZeroU64,
    ops::DerefMut,
    sync::{Arc, Mutex},
};

use windows::{
    Win32::{
        Foundation::*,
        Graphics::{
            Direct3D::*,
            Direct3D12::*,
            Dxgi::{Common::*, *},
        },
        System::SystemInformation::GetTickCount64,
        UI::{HiDpi::*, WindowsAndMessaging::*},
    },
    core::Interface,
};

/// Generated by `dxc shader.hlsl /T lib_6_3 /Fo shader.o`.
const COMPILED_SHADER: &[u8] = include_bytes!("shader.o");

/// Format to be used by the swap chain and render target.
const COLOR_FORMAT: DXGI_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM;

/// If true, GPU based validation is enabled in debug mode.
// @Todo: https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/direct3d12/use-dred.md
const DEBUG_PARANOIA: bool = false;

const SET_DEBUG_NAMES: bool = cfg!(debug_assertions);

struct Resources {
    cmd_queue: ID3D12CommandQueue,
    fence: ID3D12Fence,
    fence_value: NonZeroU64,
    swap_chain: IDXGISwapChain3,
    render_target: Option<ID3D12Resource>,
    uav_heap: ID3D12DescriptorHeap,

    cmd_allocator: ID3D12CommandAllocator,
    cmd_list: ID3D12GraphicsCommandList4,
}

struct Context {
    // factory: IDXGIFactory4,
    device: ID3D12Device5,
    resources: Resources,
}

impl Context {
    fn new(hwnd: HWND) -> windows::core::Result<Self> {
        let mut factory_flags = DXGI_CREATE_FACTORY_FLAGS::default();

        if cfg!(debug_assertions) {
            unsafe {
                let mut debug: Option<ID3D12Debug> = None;
                if let Some(debug) = D3D12GetDebugInterface(&mut debug).ok().and(debug) {
                    debug.EnableDebugLayer();

                    if DEBUG_PARANOIA {
                        let debug: ID3D12Debug1 = debug.cast()?;
                        debug.SetEnableGPUBasedValidation(true);
                    }

                    factory_flags |= DXGI_CREATE_FACTORY_DEBUG;
                }
            }
        }

        let factory: IDXGIFactory4 = unsafe { CreateDXGIFactory2(factory_flags) }?;

        let device = {
            let mut device: Option<ID3D12Device5> = None;
            unsafe { D3D12CreateDevice(None, D3D_FEATURE_LEVEL_12_2, &mut device) }?;
            device.expect("should not be null after D3D12CreateDevice is ok")
        };

        let cmd_queue: ID3D12CommandQueue = unsafe {
            device.CreateCommandQueue(&D3D12_COMMAND_QUEUE_DESC {
                Type: D3D12_COMMAND_LIST_TYPE_DIRECT,
                ..Default::default()
            })
        }?;

        let swap_chain: IDXGISwapChain3 = {
            let swap_chain1: IDXGISwapChain1 = unsafe {
                factory.CreateSwapChainForHwnd(
                    &cmd_queue,
                    hwnd,
                    &DXGI_SWAP_CHAIN_DESC1 {
                        BufferCount: 2,
                        Format: COLOR_FORMAT,
                        BufferUsage: DXGI_USAGE_RENDER_TARGET_OUTPUT,
                        SampleDesc: NO_AA,
                        SwapEffect: DXGI_SWAP_EFFECT_FLIP_DISCARD,
                        ..Default::default()
                    },
                    None,
                    None,
                )
            }?;
            swap_chain1.cast()?
        };

        // drop(factory); // @Test: the factory is no longer needed, so we may as well drop it

        // resize

        let cmd_allocator =
            unsafe { device.CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT) }?;

        let cmd_list = unsafe {
            device.CreateCommandList1(
                0,
                D3D12_COMMAND_LIST_TYPE_DIRECT,
                D3D12_COMMAND_LIST_FLAG_NONE,
            )
        }?;

        let resources = Resources {
            cmd_queue,
            fence: unsafe { device.CreateFence(0, D3D12_FENCE_FLAG_NONE) }?,
            fence_value: NonZeroU64::new(1).unwrap(),
            swap_chain,
            render_target: None, // initialized on `resize`
            uav_heap: unsafe {
                device.CreateDescriptorHeap(&D3D12_DESCRIPTOR_HEAP_DESC {
                    Type: D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
                    NumDescriptors: 1,
                    Flags: D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE,
                    ..Default::default()
                })
            }?,
            cmd_allocator,
            cmd_list,
        };

        Ok(Context { device, resources })
    }
}

struct Scene<'instances_buffer> {
    instances_buffer: ID3D12Resource,
    /// Persistently-mapped view onto `instances_buffer`.
    instance_descs: &'instances_buffer mut [D3D12_RAYTRACING_INSTANCE_DESC],

    tlas: ID3D12Resource,
    tlas_update_scratch: ID3D12Resource,

    root_signature: ID3D12RootSignature,
    pso: ID3D12StateObject,
    shader_table_buffer: ID3D12Resource,
}

impl<'instances_buffer> Scene<'instances_buffer> {
    fn new(
        context: &mut Context,
        quad_blas: &ID3D12Resource,
        cube_blas: &ID3D12Resource,
    ) -> windows::core::Result<Self> {
        let instances_buffer = make_upload_buffer(
            &context.device,
            (std::mem::size_of::<D3D12_RAYTRACING_INSTANCE_DESC>() * consts::INSTANCE_COUNT) as u64,
        )?;

        let instance_descs = {
            let mut mapped_data = std::ptr::null_mut();

            unsafe { instances_buffer.Map(0, None, Some(&mut mapped_data)) }?;

            let instances_data = mapped_data as *mut D3D12_RAYTRACING_INSTANCE_DESC;
            let instance_descs =
                unsafe { std::slice::from_raw_parts_mut(instances_data, consts::INSTANCE_COUNT) };

            // https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_raytracing_instance_desc
            //
            // typedef struct D3D12_RAYTRACING_INSTANCE_DESC {
            //     FLOAT                     Transform[3][4];
            //     UINT                      InstanceID : 24;
            //     UINT                      InstanceMask : 8;
            //     UINT                      InstanceContributionToHitGroupIndex : 24;
            //     UINT                      Flags : 8;
            //     D3D12_GPU_VIRTUAL_ADDRESS AccelerationStructure;
            // } D3D12_RAYTRACING_INSTANCE_DESC;
            //
            // `Transform` is a 3x4 transform matrix in row-major layout representing the instance-to-world transformation.
            //
            // Note: The layout of `Transform` is a transpose of how affine matrices are typically stored in memory.
            // Instead of four 3-vectors, `Transform` is laid out as three 4-vectors.

            let make_bitfield1 = |instance_id, instance_mask| {
                const MAX_U24: u32 = (1 << 24) - 1;
                const LOW_U8_MASK: u32 = 0xFF; // = (1 << 8) - 1

                (instance_id & MAX_U24) | ((instance_mask & LOW_U8_MASK) << 24)
            };

            for (i, desc) in instance_descs.iter_mut().enumerate() {
                *desc = D3D12_RAYTRACING_INSTANCE_DESC {
                    _bitfield1: make_bitfield1(i as u32, 1),
                    AccelerationStructure: unsafe {
                        if i == 0 {
                            cube_blas.GetGPUVirtualAddress() // cube
                        } else {
                            quad_blas.GetGPUVirtualAddress() // floor, mirror
                        }
                    },
                    ..Default::default()
                };
            }

            update_instance_desc_transforms(instance_descs);

            // Do not Unmap instances_buffer, such that instance_descs keeps mapped into the CPU
            // and we later call update_instance_desc_transforms in update_scene.

            instance_descs
        };

        // Init TopLevel.
        let (tlas, prebuild_info) = make_tlas(context, &instances_buffer)?;

        let tlas_update_scratch = make_unordered_access_default_buffer(
            &context.device,
            max(prebuild_info.UpdateScratchDataSizeInBytes, 8),
            D3D12_RESOURCE_STATE_COMMON, // UNORDERED_ACCESS,
        )?;

        // Init RootSignature.
        let root_signature: ID3D12RootSignature = {
            let root_params = [
                // RWTexture2D<float4> scene_output : register(u0);
                D3D12_ROOT_PARAMETER {
                    // Note: 2D typed UAVs can only be bound as part of a descriptor table,
                    // even if we only have 1.
                    ParameterType: D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE,
                    Anonymous: D3D12_ROOT_PARAMETER_0 {
                        DescriptorTable: D3D12_ROOT_DESCRIPTOR_TABLE {
                            NumDescriptorRanges: 1,
                            pDescriptorRanges: &D3D12_DESCRIPTOR_RANGE {
                                RangeType: D3D12_DESCRIPTOR_RANGE_TYPE_UAV,
                                NumDescriptors: 1,
                                ..Default::default()
                            },
                        },
                    },
                    ShaderVisibility: D3D12_SHADER_VISIBILITY_ALL,
                },
                // RaytracingAccelerationStructure scene_tlas : register(t0);
                D3D12_ROOT_PARAMETER {
                    ParameterType: D3D12_ROOT_PARAMETER_TYPE_SRV,
                    Anonymous: D3D12_ROOT_PARAMETER_0 {
                        Descriptor: D3D12_ROOT_DESCRIPTOR { ShaderRegister: 0, RegisterSpace: 0 },
                    },
                    ShaderVisibility: D3D12_SHADER_VISIBILITY_ALL,
                },
            ];

            let blob = {
                let mut blob: Option<ID3DBlob> = None;
                unsafe {
                    D3D12SerializeRootSignature(
                        &D3D12_ROOT_SIGNATURE_DESC {
                            NumParameters: root_params.len() as u32,
                            pParameters: root_params.as_ptr(),
                            Flags: D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT, // @Test
                            ..Default::default()
                        },
                        D3D_ROOT_SIGNATURE_VERSION_1_0,
                        &mut blob,
                        None,
                    )
                }?;

                blob.expect("should not be null after D3D12SerializeRootSignature is ok")
            };

            let blob_bytes: &[u8] = unsafe {
                std::slice::from_raw_parts(blob.GetBufferPointer() as _, blob.GetBufferSize())
            };

            unsafe { context.device.CreateRootSignature(0, blob_bytes) }?
        };

        // Init Pipeline.
        let subobjects = [
            D3D12_STATE_SUBOBJECT {
                Type: D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY,
                pDesc: &D3D12_DXIL_LIBRARY_DESC {
                    DXILLibrary: D3D12_SHADER_BYTECODE {
                        pShaderBytecode: COMPILED_SHADER.as_ptr() as _,
                        BytecodeLength: COMPILED_SHADER.len(),
                    },
                    ..Default::default()
                } as *const _ as _,
            },
            D3D12_STATE_SUBOBJECT {
                Type: D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP,
                pDesc: &D3D12_HIT_GROUP_DESC {
                    HitGroupExport: windows::core::w!("HitGroup"),
                    Type: D3D12_HIT_GROUP_TYPE_TRIANGLES,
                    AnyHitShaderImport: windows::core::PCWSTR::null(),
                    ClosestHitShaderImport: windows::core::w!("ClosestHit"), // [shader("closesthit")]
                    IntersectionShaderImport: windows::core::PCWSTR::null(),
                } as *const _ as _,
            },
            D3D12_STATE_SUBOBJECT {
                Type: D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG,
                pDesc: &D3D12_RAYTRACING_SHADER_CONFIG {
                    MaxPayloadSizeInBytes: 20, // sizeof(Payload) = 12 (float3) + 4 (bool) + 4 (bool)
                    MaxAttributeSizeInBytes: 8, // sizeof(BuiltInTriangleIntersectionAttributes) == 8 (float2 barycentrics)
                } as *const _ as _,
            },
            D3D12_STATE_SUBOBJECT {
                Type: D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG,
                pDesc: &D3D12_RAYTRACING_PIPELINE_CONFIG {
                    MaxTraceRecursionDepth: 3, // @Hardcode: camera -1-> mirror -2-> floor -3-> light
                } as *const _ as _,
            },
            D3D12_STATE_SUBOBJECT {
                Type: D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE,
                pDesc: &D3D12_GLOBAL_ROOT_SIGNATURE {
                    pGlobalRootSignature: std::mem::ManuallyDrop::new(Some(root_signature.clone())), // @Leak
                } as *const _ as _,
            },
        ];

        let pso: ID3D12StateObject = unsafe {
            context.device.CreateStateObject(&D3D12_STATE_OBJECT_DESC {
                Type: D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE,
                NumSubobjects: subobjects.len() as u32,
                pSubobjects: subobjects.as_ptr(),
            })
        }?;

        let shader_table_buffer = make_upload_buffer(
            &context.device,
            (D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT * 3) as u64, // [shader("...")] x3
        )?;

        {
            let pso_props: ID3D12StateObjectProperties = pso.cast()?;

            let mut mapped_data = std::ptr::null_mut();

            unsafe { shader_table_buffer.Map(0, None, Some(&mut mapped_data)) }?;

            for (i, id) in [
                windows::core::w!("RayGeneration"), // [shader("raygeneration")]
                windows::core::w!("Miss"),          // [shader("miss")]
                // Shader 'ClosestHit' is not a shader type that supports producing shader identifiers.
                // Shader type must be RayGeneration, Miss, Callable or a HitGroup.
                windows::core::w!("HitGroup"), // [shader("closesthit")]
            ]
            .into_iter()
            .enumerate()
            {
                unsafe {
                    let id = pso_props.GetShaderIdentifier(id) as *mut u8;
                    id.copy_to_nonoverlapping(
                        (mapped_data as *mut u8)
                            .add(i * D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT as usize),
                        D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES as usize,
                    );
                }
            }

            unsafe { shader_table_buffer.Unmap(0, None) };
        }

        Ok(Scene {
            instances_buffer,
            instance_descs,
            tlas,
            tlas_update_scratch,
            root_signature,
            pso,
            shader_table_buffer,
        })
    }

    unsafe fn record_update(
        &mut self,
        cmd_list: &ID3D12GraphicsCommandList4,
    ) -> windows::core::Result<()> {
        update_instance_desc_transforms(self.instance_descs);

        let build_desc = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
            DestAccelerationStructureData: unsafe { self.tlas.GetGPUVirtualAddress() },
            Inputs: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
                Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL,
                Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE,
                NumDescs: consts::INSTANCE_COUNT as u32,
                DescsLayout: D3D12_ELEMENTS_LAYOUT_ARRAY,
                Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
                    InstanceDescs: unsafe { self.instances_buffer.GetGPUVirtualAddress() },
                },
            },
            SourceAccelerationStructureData: unsafe { self.tlas.GetGPUVirtualAddress() },
            ScratchAccelerationStructureData: unsafe {
                self.tlas_update_scratch.GetGPUVirtualAddress()
            },
        };

        unsafe {
            // @Test: record_uav_barrier.
            cmd_list.BuildRaytracingAccelerationStructure(&build_desc, None);
            record_uav_barrier(cmd_list, &self.tlas);
        }

        Ok(())
    }
}

fn main() -> windows::core::Result<()> {
    println!("Hello, DXR!");

    println!("Shader byte count: {}", COMPILED_SHADER.len());

    // @Todo: add a CLI option to DPI_AWARENESS_CONTEXT_UNAWARE (e.g. --dpi-unaware).
    unsafe { SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) }?;

    let class_name = windows::core::w!("HelloDxrClass");

    let wcw = WNDCLASSW {
        lpfnWndProc: Some(wnd_proc),
        hCursor: unsafe { LoadCursorW(None, IDC_ARROW) }?,
        lpszClassName: class_name,
        ..Default::default()
    };
    let atom = unsafe { RegisterClassW(&wcw) };
    assert_ne!(atom, 0, "RegisterClassW: {:?}", unsafe { GetLastError() });

    let hwnd = unsafe {
        CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            class_name,
            windows::core::w!("Hello DXR"),
            WS_VISIBLE | WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            None,
            None,
            None,
            None,
        )
    }?;

    let context = Arc::new(Mutex::new(Context::new(hwnd)?));

    // @Test: instead of moving the cloned value with Arc::into_raw, just cast the context to
    // a `*mut Mutex<Context>` and avoid `drop(unsafe { Arc::from_raw(context_ptr) })` in `wnd_proc`.
    let context_for_window = Arc::clone(&context);
    unsafe { SetWindowLongPtrW(hwnd, GWLP_USERDATA, Arc::into_raw(context_for_window) as isize) };

    if SET_DEBUG_NAMES {
        unsafe {
            use windows::core::w;

            let context = &context.lock().unwrap();
            context.device.cast::<ID3D12Object>().unwrap().SetName(w!("device"))?;
            context.resources.cmd_queue.cast::<ID3D12Object>().unwrap().SetName(w!("cmd_queue"))?;
            context.resources.cmd_queue.cast::<ID3D12Object>().unwrap().SetName(w!("cmd_queue"))?;
            context.resources.fence.cast::<ID3D12Object>().unwrap().SetName(w!("fence"))?;
            //context.resources.swap_chain.cast::<ID3D12Object>().unwrap().SetName(w!("swap_chain"))?;
            context.resources.uav_heap.cast::<ID3D12Object>().unwrap().SetName(w!("uav_heap"))?;
        }
    }

    resize(hwnd, std::ptr::NonNull::new(context.as_ref() as *const _ as *mut _).unwrap());

    // Init Meshes.
    let quad_vertex_buffer =
        make_upload_buffer_from_slice(&context.lock().unwrap().device, &consts::QUAD_VERTICES)?;
    let cube_vertex_buffer =
        make_upload_buffer_from_slice(&context.lock().unwrap().device, &consts::CUBE_VERTICES)?;
    let cube_index_buffer =
        make_upload_buffer_from_slice(&context.lock().unwrap().device, &consts::CUBE_INDICES)?;

    // Init BottomLevel.
    let quad_blas = make_blas(
        context.lock().unwrap().deref_mut(),
        &quad_vertex_buffer,
        (consts::QUAD_VERTICES.len() / 3) as u32,
        None,
    )?;
    let cube_blas = make_blas(
        context.lock().unwrap().deref_mut(),
        &cube_vertex_buffer,
        (consts::CUBE_VERTICES.len() / 3) as u32,
        Some((&cube_index_buffer, consts::CUBE_INDICES.len() as u32)),
    )?;

    if SET_DEBUG_NAMES {
        unsafe {
            use windows::core::w;

            quad_vertex_buffer.cast::<ID3D12Object>().unwrap().SetName(w!("quad_vertex_buffer"))?;
            cube_vertex_buffer.cast::<ID3D12Object>().unwrap().SetName(w!("cube_vertex_buffer"))?;
            cube_index_buffer.cast::<ID3D12Object>().unwrap().SetName(w!("cube_index_buffer"))?;

            quad_blas.cast::<ID3D12Object>().unwrap().SetName(w!("quad_blas"))?;
            cube_blas.cast::<ID3D12Object>().unwrap().SetName(w!("cube_blas"))?;
        }
    }

    // Init Scene.
    let mut scene = Scene::new(context.lock().unwrap().deref_mut(), &quad_blas, &cube_blas)?;

    if SET_DEBUG_NAMES {
        unsafe {
            use windows::core::w;

            scene
                .instances_buffer
                .cast::<ID3D12Object>()
                .unwrap()
                .SetName(w!("instances_buffer"))?;
            scene.tlas.cast::<ID3D12Object>().unwrap().SetName(w!("tlas"))?;
            scene
                .tlas_update_scratch
                .cast::<ID3D12Object>()
                .unwrap()
                .SetName(w!("tlas_update_scratch"))?;
            scene.root_signature.cast::<ID3D12Object>().unwrap().SetName(w!("root_signature"))?;
            scene.pso.cast::<ID3D12Object>().unwrap().SetName(w!("pso"))?;
            scene
                .shader_table_buffer
                .cast::<ID3D12Object>()
                .unwrap()
                .SetName(w!("shader_table_buffer"))?;
        }
    }

    let mut msg = MSG::default();
    loop {
        while unsafe { PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() } {
            if msg.message == WM_QUIT {
                return Ok(());
            }

            unsafe {
                let _translated = TranslateMessage(&msg).as_bool();
                // @Fixme: assert!(translated, "TranslateMessage: {:?}", GetLastError());
                DispatchMessageW(&msg);
            }
        }

        match context.lock().unwrap().deref_mut() {
            Context { device, resources } => {
                if let Err(err) = render_frame(resources, &mut scene) {
                    eprintln!("render_frame failed: {:?}", err);
                    if let Err(reason) = unsafe { device.GetDeviceRemovedReason() } {
                        eprintln!("GetDeviceRemovedReason: {:?}", reason);
                    }
                    return Err(err);
                }
            }
        }
    }
}

fn update_instance_desc_transforms(instance_descs: &mut [D3D12_RAYTRACING_INSTANCE_DESC]) {
    let [cube_to_world, floor_to_world, mirror_to_world] =
        transform::compute_instance_to_world_transforms(
            unsafe { GetTickCount64() } as f32 / 1000.0,
        );

    instance_descs[0].Transform.copy_from_slice(&cube_to_world);
    instance_descs[1].Transform.copy_from_slice(&floor_to_world);
    instance_descs[2].Transform.copy_from_slice(&mirror_to_world);
}

fn render_frame(resources: &mut Resources, scene: &mut Scene) -> windows::core::Result<()> {
    let render_target = resources.render_target.as_ref().unwrap();

    let dispatch_rays_desc = {
        let D3D12_RESOURCE_DESC { Width, Height, .. } = unsafe { render_target.GetDesc() };

        let base_addr = unsafe { scene.shader_table_buffer.GetGPUVirtualAddress() };

        D3D12_DISPATCH_RAYS_DESC {
            RayGenerationShaderRecord: D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
                StartAddress: base_addr + 0 * D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT as u64,
                SizeInBytes: D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES as u64,
            },
            MissShaderTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
                StartAddress: base_addr + 1 * D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT as u64,
                SizeInBytes: D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES as u64,
                StrideInBytes: 0, // @Test: D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT as u64,
            },
            HitGroupTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
                StartAddress: base_addr + 2 * D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT as u64,
                SizeInBytes: D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES as u64,
                StrideInBytes: 0, // @Test: D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT as u64,
            },
            CallableShaderTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE::default(),
            Width: Width as u32,
            Height,
            Depth: 1,
        }
    };

    unsafe {
        resources.cmd_allocator.Reset()?;
        resources.cmd_list.Reset(&resources.cmd_allocator, None)?;

        scene.record_update(&resources.cmd_list)?; // does BuildRaytracingAccelerationStructure

        resources.cmd_list.SetPipelineState1(&scene.pso);
        resources.cmd_list.SetComputeRootSignature(&scene.root_signature);
        resources.cmd_list.SetDescriptorHeaps(&[Some(resources.uav_heap.clone())]);
        resources.cmd_list.SetComputeRootDescriptorTable(
            0, // u0: UAV (scene_output)
            resources.uav_heap.GetGPUDescriptorHandleForHeapStart(),
        );
        resources.cmd_list.SetComputeRootShaderResourceView(
            1, // t0: TLAS (scene_tlas)
            scene.tlas.GetGPUVirtualAddress(),
        );

        resources.cmd_list.DispatchRays(&dispatch_rays_desc);

        let bb_index = resources.swap_chain.GetCurrentBackBufferIndex();
        let back_buffer: ID3D12Resource = resources.swap_chain.GetBuffer(bb_index)?;
        if SET_DEBUG_NAMES {
            back_buffer
                .cast::<ID3D12Object>()
                .unwrap()
                .SetName(windows::core::w!("back_buffer"))?;
        }

        record_transition_barrier(
            &resources.cmd_list,
            render_target,
            D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
            D3D12_RESOURCE_STATE_COPY_SOURCE,
        );
        record_transition_barrier(
            &resources.cmd_list,
            &back_buffer,
            D3D12_RESOURCE_STATE_PRESENT,
            D3D12_RESOURCE_STATE_COPY_DEST,
        );

        resources.cmd_list.CopyResource(&back_buffer, render_target);

        record_transition_barrier(
            &resources.cmd_list,
            &back_buffer,
            D3D12_RESOURCE_STATE_COPY_DEST,
            D3D12_RESOURCE_STATE_PRESENT,
        );
        record_transition_barrier(
            &resources.cmd_list,
            render_target,
            D3D12_RESOURCE_STATE_COPY_SOURCE,
            D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
        );

        drop(back_buffer);

        resources.cmd_list.Close()?;
        resources.cmd_queue.ExecuteCommandLists(&[Some(resources.cmd_list.cast()?)]);
    };

    resources.fence_value =
        signal_and_wait(resources.fence_value, &resources.cmd_queue, &resources.fence)?;

    unsafe {
        // @Fixme: Present failed: HRESULT(0x887A0005)
        //
        // D3D12 ERROR: ID3D12Device::RemoveDevice: Device removal has been triggered for the following reason
        // (DXGI_ERROR_DEVICE_HUNG:
        //  The Device took an unreasonable amount of time to execute its commands, or the hardware crashed/hung.
        //  As a result, the TDR (Timeout Detection and Recovery) mechanism has been triggered.
        //  The current Device Context was executing commands when the hang occurred.
        //  The application may want to respawn and fallback to less aggressive use of the display hardware).
        // [ EXECUTION ERROR #232: DEVICE_REMOVAL_PROCESS_AT_FAULT]
        let hr = resources.swap_chain.Present(1, DXGI_PRESENT::default());

        if hr.is_err() {
            eprintln!("Present failed: {:?}", hr);
            return Err(windows::core::Error::from_hresult(hr));
        }
    };

    Ok(())
}

fn signal_and_wait(
    fence_value: NonZeroU64,
    cmd_queue: &ID3D12CommandQueue,
    fence: &ID3D12Fence,
) -> windows::core::Result<NonZeroU64> {
    unsafe {
        cmd_queue.Signal(fence, fence_value.get())?;
        // Pass HANDLE::default() to lead to a blocking wait.
        fence.SetEventOnCompletion(fence_value.get(), HANDLE::default())?;
    }

    Ok(fence_value.saturating_add(1))
}

unsafe fn record_uav_barrier(cmd_list: &ID3D12GraphicsCommandList4, resource: &ID3D12Resource) {
    unsafe {
        cmd_list.ResourceBarrier(&[D3D12_RESOURCE_BARRIER {
            Type: D3D12_RESOURCE_BARRIER_TYPE_UAV,
            Flags: D3D12_RESOURCE_BARRIER_FLAG_NONE,
            Anonymous: D3D12_RESOURCE_BARRIER_0 {
                UAV: std::mem::ManuallyDrop::new(D3D12_RESOURCE_UAV_BARRIER {
                    pResource: std::mem::ManuallyDrop::new(Some(resource.clone())), // @Leak
                }),
            },
        }])
    };
}

unsafe fn record_transition_barrier(
    cmd_list: &ID3D12GraphicsCommandList4,
    resource: &ID3D12Resource,
    before: D3D12_RESOURCE_STATES,
    after: D3D12_RESOURCE_STATES,
) {
    unsafe {
        cmd_list.ResourceBarrier(&[D3D12_RESOURCE_BARRIER {
            Type: D3D12_RESOURCE_BARRIER_TYPE_TRANSITION,
            Flags: D3D12_RESOURCE_BARRIER_FLAG_NONE,
            Anonymous: D3D12_RESOURCE_BARRIER_0 {
                Transition: std::mem::ManuallyDrop::new(D3D12_RESOURCE_TRANSITION_BARRIER {
                    pResource: std::mem::ManuallyDrop::new(Some(resource.clone())), // @Leak
                    Subresource: 0, // @Test: D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,
                    StateBefore: before,
                    StateAfter: after,
                }),
            },
        }])
    };
}

fn make_upload_buffer(
    device: &ID3D12Device5,
    size_in_bytes: u64,
) -> windows::core::Result<ID3D12Resource> {
    let buffer = {
        let mut desc = consts::BASIC_BUFFER_DESC;
        desc.Width = size_in_bytes;

        let mut buffer: Option<ID3D12Resource> = None;
        unsafe {
            device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_UPLOAD, ..Default::default() },
                D3D12_HEAP_FLAG_NONE,
                &desc,
                D3D12_RESOURCE_STATE_COMMON,
                None,
                &mut buffer,
            )
        }?;

        buffer.expect("should not be null after CreateCommittedResource is ok")
    };

    Ok(buffer)
}

fn make_upload_buffer_from_slice<T: Copy>(
    device: &ID3D12Device5,
    data: &[T],
) -> windows::core::Result<ID3D12Resource> {
    make_upload_buffer(device, std::mem::size_of_val(data) as u64).and_then(|buffer| {
        let mut mapped_data = std::ptr::null_mut();
        unsafe {
            buffer.Map(0, None, Some(&mut mapped_data))?;
            data.as_ptr().copy_to_nonoverlapping(mapped_data as *mut T, data.len());
            buffer.Unmap(0, None);
        }

        Ok(buffer)
    })
}

fn make_unordered_access_default_buffer(
    device: &ID3D12Device5,
    size_in_bytes: u64,
    initial_state: D3D12_RESOURCE_STATES,
) -> windows::core::Result<ID3D12Resource> {
    let buffer = {
        let mut desc = consts::BASIC_BUFFER_DESC;
        desc.Width = size_in_bytes;
        desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

        let mut buffer: Option<ID3D12Resource> = None;
        unsafe {
            device.CreateCommittedResource(
                &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_DEFAULT, ..Default::default() },
                D3D12_HEAP_FLAG_NONE,
                &desc,
                initial_state,
                None,
                &mut buffer,
            )
        }?;

        buffer.expect("should not be null after CreateCommittedResource is ok")
    };

    Ok(buffer)
}

fn make_acceleration_structure(
    context: &mut Context,
    inputs: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
) -> windows::core::Result<(ID3D12Resource, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO)>
{
    let Context { device, resources } = context;

    let mut prebuild_info = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO::default();
    unsafe { device.GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &mut prebuild_info) };

    let scratch_buffer = make_unordered_access_default_buffer(
        device,
        prebuild_info.ScratchDataSizeInBytes,
        D3D12_RESOURCE_STATE_COMMON, // UNORDERED_ACCESS,
    )?;
    let result_buffer = make_unordered_access_default_buffer(
        device,
        prebuild_info.ResultDataMaxSizeInBytes,
        D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE,
    )?;

    let build_desc = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
        DestAccelerationStructureData: unsafe { result_buffer.GetGPUVirtualAddress() },
        Inputs: inputs,
        SourceAccelerationStructureData: 0,
        ScratchAccelerationStructureData: unsafe { scratch_buffer.GetGPUVirtualAddress() },
    };

    unsafe {
        resources.cmd_allocator.Reset()?;
        resources.cmd_list.Reset(&resources.cmd_allocator, None)?;

        resources.cmd_list.BuildRaytracingAccelerationStructure(&build_desc, None);

        resources.cmd_list.Close()?;
        resources.cmd_queue.ExecuteCommandLists(&[Some(resources.cmd_list.cast()?)]);
    };

    resources.fence_value =
        signal_and_wait(resources.fence_value, &resources.cmd_queue, &resources.fence)?;

    Ok((result_buffer, prebuild_info))
}

fn make_blas(
    context: &mut Context,
    vertex_buffer: &ID3D12Resource,
    vertex_count: u32,
    index_buffer_and_count: Option<(&ID3D12Resource, u32)>,
) -> windows::core::Result<ID3D12Resource> {
    let (index_format, index_count, index_buffer) = match index_buffer_and_count {
        // @Hardcode: DXGI_FORMAT_R16_UINT matches the u16 used for CUBE_INDICES.
        Some((index_buffer, count)) => {
            (DXGI_FORMAT_R16_UINT, count, unsafe { index_buffer.GetGPUVirtualAddress() })
        }
        None => (DXGI_FORMAT_UNKNOWN, 0, 0),
    };

    let geometry_desc = D3D12_RAYTRACING_GEOMETRY_DESC {
        Type: D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES,
        Flags: D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE,
        Anonymous: D3D12_RAYTRACING_GEOMETRY_DESC_0 {
            Triangles: D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
                Transform3x4: 0,
                IndexFormat: index_format,
                VertexFormat: DXGI_FORMAT_R32G32B32_FLOAT,
                IndexCount: index_count,
                VertexCount: vertex_count,
                IndexBuffer: index_buffer,
                VertexBuffer: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
                    StartAddress: unsafe { vertex_buffer.GetGPUVirtualAddress() },
                    StrideInBytes: (std::mem::size_of::<f32>() * 3) as u64, // @Hardcode
                },
            },
        },
    };

    // See https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#choosing-acceleration-structure-build-flags
    let inputs = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
        Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL,
        Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE,
        NumDescs: 1,
        DescsLayout: D3D12_ELEMENTS_LAYOUT_ARRAY,
        Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
            pGeometryDescs: &geometry_desc,
        },
    };

    make_acceleration_structure(context, inputs).map(|(result_buffer, _)| result_buffer)
}

fn make_tlas(
    context: &mut Context,
    instances_buffer: &ID3D12Resource,
) -> windows::core::Result<(ID3D12Resource, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO)>
{
    let inputs = D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
        Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL,
        Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE,
        NumDescs: consts::INSTANCE_COUNT as u32,
        DescsLayout: D3D12_ELEMENTS_LAYOUT_ARRAY,
        Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
            InstanceDescs: unsafe { instances_buffer.GetGPUVirtualAddress() },
        },
    };

    make_acceleration_structure(context, inputs)
}

extern "system" fn resize(hwnd: HWND, mut context: std::ptr::NonNull<Mutex<Context>>) {
    let mut context = unsafe { context.as_mut() }.lock().unwrap();
    let Context { device, resources } = &mut *context;

    let mut rect = RECT::default();
    unsafe { GetClientRect(hwnd, &mut rect) }.unwrap();
    let width = max(1, rect.right - rect.left);
    let height = max(1, rect.bottom - rect.top);

    resources.fence_value =
        signal_and_wait(resources.fence_value, &resources.cmd_queue, &resources.fence).unwrap();

    unsafe {
        resources.swap_chain.ResizeBuffers(
            0u32, // preserve buffer count
            width as u32,
            height as u32,
            DXGI_FORMAT_UNKNOWN, // preserve existing format
            DXGI_SWAP_CHAIN_FLAG(0),
        )
    }
    .unwrap();

    resources.render_target.take(); // @Test

    assert!(resources.render_target.is_none());

    unsafe {
        device.CreateCommittedResource(
            &D3D12_HEAP_PROPERTIES { Type: D3D12_HEAP_TYPE_DEFAULT, ..Default::default() },
            D3D12_HEAP_FLAG_NONE,
            &D3D12_RESOURCE_DESC {
                Dimension: D3D12_RESOURCE_DIMENSION_TEXTURE2D,
                Width: width as u64,
                Height: height as u32,
                DepthOrArraySize: 1,
                MipLevels: 1,
                Format: COLOR_FORMAT,
                SampleDesc: NO_AA,
                Flags: D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
                ..Default::default()
            },
            D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
            None,
            &mut resources.render_target,
        )
    }
    .unwrap();

    assert!(resources.render_target.is_some());

    let render_target = resources
        .render_target
        .as_ref()
        .expect("should not be null after CreateCommittedResource is ok");

    if SET_DEBUG_NAMES {
        unsafe {
            render_target
                .cast::<ID3D12Object>()
                .unwrap()
                .SetName(windows::core::w!("render_target"))
                .unwrap();
        }
    }

    unsafe {
        device.CreateUnorderedAccessView(
            render_target,
            None,
            Some(&D3D12_UNORDERED_ACCESS_VIEW_DESC {
                Format: COLOR_FORMAT,
                ViewDimension: D3D12_UAV_DIMENSION_TEXTURE2D,
                ..Default::default()
            }),
            resources.uav_heap.GetCPUDescriptorHandleForHeapStart(),
        )
    };
}

extern "system" fn wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    let context_ptr = unsafe { GetWindowLongPtrW(hwnd, GWLP_USERDATA) } as *const Mutex<Context>
        as *mut Mutex<Context>;

    match msg {
        WM_SIZING | WM_SIZE => {
            if let Some(context) = std::ptr::NonNull::new(context_ptr) {
                resize(hwnd, context); // @Fixme
            }
        }
        WM_CLOSE | WM_DESTROY => {
            if !context_ptr.is_null() {
                // Decrease the refcount as we close the window.
                drop(unsafe { Arc::from_raw(context_ptr) });
            }
            unsafe { PostQuitMessage(0) };
            // @Test: resize(?)
        }
        _ => {}
    }

    unsafe { DefWindowProcW(hwnd, msg, wparam, lparam) }
}
